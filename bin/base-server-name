#!/bin/bash

# jtingiris

# this script will output the 'base-name' of a given directory

# a 'base-name' is defined as the directory name translated to a dns/host name, using the following logic

# begin base.bash.include

PATH=/bin:/usr/bin:/sbin:/usr/sbin

INCLUDE_FILE="base.bash"
INCLUDE_FOUND=0
INCLUDE_PATHS="$(dirname $0) $(pwd)"
for INCLUDE_PATH in $INCLUDE_PATHS; do
    if [ $INCLUDE_FOUND -eq 1 ]; then break; fi
    while [ ! -z "$INCLUDE_PATH" ]; do
        if [ "$INCLUDE_PATH" == "." ]; then INCLUDE_PATH=$(pwd -L .); fi
        if [ "$INCLUDE_PATH" == "/" ]; then break; fi
        if [ -r "$INCLUDE_PATH/include/$INCLUDE_FILE" ] && [ ! -d "$INCLUDE_PATH/include/$INCLUDE_FILE" ]; then
            INCLUDE_FOUND=1
            source "$INCLUDE_PATH/include/$INCLUDE_FILE"
            Debug "sourced $INCLUDE_PATH/include/$INCLUDE_FILE" 500
            break
        else
            INCLUDE_PATH=`dirname "$INCLUDE_PATH"`
        fi
    done
done
if [ $INCLUDE_FOUND -ne 1 ]; then echo "$INCLUDE_FILE file not found"; exit 1; fi
if [ "$BASE_INCLUDE" == "" ]; then echo "$INCLUDE_FILE file invalid"; exit 1; fi
unset INCLUDE_PATH INCLUDE_FILE

# end base.bash.include

# GLOBALS

# do not put these in the server name heirarchy
BASE_IGNORES="@ account archetype bin certificate cloudio cloudsite content content.default etc html include log sbin session usr tmp"

ACCOUNT_FLAG=0
DOCUMENT_ROOT_FLAG=0
DOMAIN_NAME_FLAG=0
PREFIX_FLAG=0
SERVER_NAME_FLAG=0

PATH=/base/bin:/base/sbin:/bin:/sbin

function Base_Server_Name() {
    local base_server_name_input="$1"

    if [ "$base_server_name_input" == "" ]; then return; fi

    Debug_Variable base_server_name_input 1

    local base_server_name_array=($(echo "$base_server_name_input"))
    for (( index=${#base_server_name_array[@]}-1 ; index>=0 ; index-- )) ; do
        local skip=0
        for BASE_IGNORE in $BASE_IGNORES; do
            if [ "${base_server_name_array[index]}" == "${BASE_IGNORE}" ]; then
                local skip=1
            fi
        done
        if [ $skip -eq 1 ]; then continue; fi

        if [ "$BASE_SERVER_NAME" == "" ]; then
            BASE_SERVER_NAME="${base_server_name_array[index]}"
        else
            BASE_SERVER_NAME+=".${base_server_name_array[index]}"
        fi
    done
}

function Usage() {
    Debug_Function $@

    local note="$1"

    # begin function logic

    echo
    echo "usage: $0 <directory> [options]"
    echo
    echo "options:"
    echo
    # these are handled in base.bash; useful to know though ...
    echo "  -D | --debug [level]           = print debug messages (less than) [level]"
    echo "  -H | --help                    = print this message"
    echo "  -V | --version                 = print version"
    echo
    # these must be handled in this script; please keep usage messages accurate
    #echo "  --no                           = answer 'no' to all questions"
    echo "  -a | --account                 = print the account name"
    echo "  -d | --domain-name             = print the domain name"
    echo "  -p | --prefix                  = print the prefix"
    echo "  -r | --document-root           = print the document-root"
    echo "  -s | --server-name             = print the server-name (default)"
    echo

    if [ "$note" != "" ]; then
        echo "NOTE: $note"
        echo
    fi

    # end function logic

    Debug_Function $@

    Stop 1
}

Options $@

# 0 = grab the first argument, before processing options, or it will be lost due to shift
if [ "$1" != "" ]; then
    if [ "$1" == "." ]; then
        BASE_INPUT=$(readlink -f $(pwd))
    else
        BASE_INPUT="$1"
    fi
else
    BASE_INPUT=$(readlink -f $(pwd))
fi

# expand upon the base Options function (careful, same named switches will be processed twice)

# for each command line argument, evaluate them case by case, process them, and shift to the next
for ((ARGUMENT=1; ARGUMENT <= $ARGUMENTS_TOTAL; ARGUMENT++)); do
    case "$1" in
    -a | --account | -account)
        ACCOUNT_FLAG=1
        ;;
    -d | --domain-name | -domain-name)
        DOMAIN_NAME_FLAG=1
        ;;
    -r | --document-root | -document-root)
        DOCUMENT_ROOT_FLAG=1
        ;;
    -p | --prefix | -prefix)
        PREFIX_FLAG=1
        ;;
    -s | --server-name | -server-name)
        SERVER_NAME_FLAG=1
        ;;
    esac
    shift
done

Start

Debug_Variable BASE_INPUT 1

# 1 - validate BASE_DIR is on this machine, or do nothing
Debug_Variable BASE_DIR 1
if [ ! -d "$BASE_DIR" ]; then
    Aborting "$BASE_DIR directory not found" 1
fi

# 2 - strip the leading / from BASE_DIR to use as BASE_1, if the result is NULL then do nothing
BASE_1=$(echo "$BASE_DIR" | sed -e "s/^\///g")
if [ "$BASE_1" == "" ]; then
    Aborting "$BASE_DIR directory invalid" 1
else
    # BASE_1 is valid
    Debug_Variable BASE_1 1
    BASE_IGNORES+=" ${BASE_1}"
fi

# 3 - validate BASE_INPUT starts with a variation of BASE_1, or do nothing
BASE_1_OK=$(echo "$BASE_INPUT" | egrep -e "^${BASE_1}$|^${BASE_1}\/|^\/${BASE_1}" | sed -e 's/^\///g' -e 's/\/$//g' | awk -Fhtml '{print $1}')
if [ -h "$BASE_1_OK" ]; then
    Aborting "$BASE_1_OK is a link"
fi
if [ "$BASE_1_OK" == "" ]; then
    Aborting "invalid input ($BASE_INPUT)" 1
    exit 1
else
    # BASE_1 is OK
    Debug_Variable BASE_1_OK 1
fi


# 3 - validate BASE_1_OK contains a second level separated by /
BASE_2=$(echo "$BASE_1_OK" | awk -F\/ '{print $2}')
if [ "$BASE_2" == "" ]; then
    BASE_2_OK=0
else
    BASE_2_OK=0
    Debug_Variable BASE_2 1
    if [ -d "${BASE_DIR}/${BASE_2}" ]; then
        Debug "${BASE_DIR}/${BASE_2} directory found" 20
        for BASE_IGNORE in $BASE_IGNORES; do
            # this is an important bit of logic;
            # only BASE_2 names that DO NOT match something in the ignore list will be
            # appended to the resulting BASE_SERVER_NAME
            if [ "${BASE_2}" == "${BASE_IGNORE}" ]; then
                Debug_Variable BASE_IGNORE 20 "ignore $BASE_2"
                BASE_2_OK=0
                break;
            else
                Debug_Variable BASE_IGNORE 20 "ok $BASE_2"
                BASE_2_OK=1
            fi
        done
    else
        Debug "${BASE_DIR}/${BASE_2} directory not found" 20
        BASE_2_OK=1
    fi
fi
Debug_Variable BASE_2_OK 1

# 4 - validate BASE_1_OK contains a third level separated by /
BASE_3=$(echo "$BASE_1_OK" | awk -F\/ '{print $3}')
if [ "$BASE_3" == "" ]; then
    BASE_3_OK=0
else
    BASE_3_OK=0
    Debug_Variable BASE_3 1
    for BASE_IGNORE in $BASE_IGNORES; do
        if [ "${BASE_3}" == "${BASE_IGNORE}" ]; then
            Debug_Variable BASE_IGNORE 20 "ignore $BASE_3"
            BASE_3_OK=0
            break;
        else
            Debug_Variable BASE_IGNORE 20 "ok $BASE_3"
            BASE_3_OK=1
        fi
    done
    # the account directory is special; don't include BASE_3 if it's in the path
    if [ "${BASE_2}" == "account" ]; then
        BASE_3_OK=0
    fi
fi
Debug_Variable BASE_3_OK 1

# 5 - validate BASE_1_OK contains a fourth level separated by /
BASE_4=$(echo "$BASE_1_OK" | awk -F\/ '{print $4}')
if [ "$BASE_4" == "" ]; then
    BASE_4_OK=0
else
    BASE_4_OK=0
    Debug_Variable BASE_4 1
    for BASE_IGNORE in $BASE_IGNORES; do
        if [ "${BASE_4}" == "${BASE_IGNORE}" ]; then
            Debug_Variable BASE_IGNORE 20 "ignore $BASE_4"
            BASE_4_OK=0
            break;
        else
            Debug_Variable BASE_IGNORE 20 "ok $BASE_4"
            BASE_4_OK=1
        fi
    done
fi
Debug_Variable BASE_4_OK 1

# only the first element is valid
if [ "$BASE_SERVER_NAME" == "" ] && [ $BASE_2_OK -eq 0 ] && [ $BASE_3_OK -eq 0 ] && [ $BASE_4_OK -eq 0 ]; then
    Base_Server_Name "${BASE_1}"
fi

# only the second element is valid
if [ "$BASE_SERVER_NAME" == "" ] && [ $BASE_2_OK -eq 1 ] && [ $BASE_3_OK -eq 0 ] && [ $BASE_4_OK -eq 0 ]; then
    Base_Server_Name "${BASE_2}"
fi

# only the first & second elements are valid
if [ "$BASE_SERVER_NAME" == "" ] && [ $BASE_2_OK -eq 1 ] && [ $BASE_3_OK -eq 1 ] && [ $BASE_4_OK -eq 0 ]; then
    Base_Server_Name "${BASE_2} ${BASE_3}"
fi

# only the third element is valid
if [ "$BASE_SERVER_NAME" == "" ] && [ $BASE_2_OK -eq 0 ] && [ $BASE_3_OK -eq 1 ] && [ $BASE_4_OK -eq 0 ]; then
    Base_Server_Name "${BASE_3}"
fi

# only the fourth element is valid
if [ "$BASE_SERVER_NAME" == "" ] && [ $BASE_2_OK -eq 0 ] && [ $BASE_3_OK -eq 0 ] && [ $BASE_4_OK -eq 1 ]; then
    Base_Server_Name "$(echo "$BASE_1_OK" | awk -F\/ '{$1=$2=$3=""; print $0}')"
fi

# the third & fourth elements are valid
if [ "$BASE_SERVER_NAME" == "" ] && [ $BASE_2_OK -eq 0 ] && [ $BASE_3_OK -eq 1 ] && [ $BASE_4_OK -eq 1 ]; then
    Base_Server_Name "$(echo "$BASE_1_OK" | awk -F\/ '{$1=$2=$3=""; print $0}') ${BASE_3}"
fi

# all elements are valid
if [ "$BASE_SERVER_NAME" == "" ] && [ $BASE_2_OK -eq 1 ] && [ $BASE_3_OK -eq 1 ] && [ $BASE_4_OK -eq 1 ]; then
    Base_Server_Name "${BASE_2} ${BASE_3} $(echo "$BASE_1_OK" | awk -F\/ '{$1=$2=$3=""; print $0}')"
    #Base_Server_Name "${BASE_3} ${BASE_2} ${BASE_1} $(echo "$BASE_1_OK" | awk -F\/ '{$1=$2=$3=""; print $0}')"
fi

if [ "$BASE_SERVER_NAME" == "" ]; then
    if [ "${BASE_2}" == "account" ]; then
        if [ "${BASE_3}" != "" ]; then
            BASE_SERVER_NAME="${BASE_3}"
        else
            BASE_SERVER_NAME="${BASE_1}"
        fi
    else
        BASE_SERVER_NAME="${BASE_1}"
    fi
fi

Debug_Variable BASE_SERVER_NAME 1

FLAGGED=0

if [ $ACCOUNT_FLAG -eq 1 ]; then
    FLAGGED=1
    if [ "${BASE_2}" == "account" ]; then
        if [ "${BASE_3}" != "" ]; then
            echo "${BASE_3}"
        else
            echo "${BASE_1}"
        fi
    else
        echo "${BASE_1}"
    fi
fi

if [ $DOCUMENT_ROOT_FLAG -eq 1 ]; then
    FLAGGED=1
    if [ "$BASE_2" == "account" ]; then
        DOCUMENT_ROOT="/${BASE_1_OK}/html"
    else
        DOCUMENT_ROOT=$(echo "/${BASE_1_OK}/" | sed -e 's#//#/#g')
        Debug_Variable DOCUMENT_ROOT 20
        for BASE_IGNORE in $BASE_IGNORES; do
            DOCUMENT_ROOT=$(echo "$DOCUMENT_ROOT" | sed -e "s#/$BASE_IGNORE/##g" -e "s#/${BASE_IGNORE}\$##g")
            Debug_Variable DOCUMENT_ROOT 20 "$BASE_IGNORE"
        done
        DOCUMENT_ROOT+="/"
        DOCUMENT_ROOT="/${BASE_1}/${DOCUMENT_ROOT}/html"
    fi
    DOCUMENT_ROOT=$(echo "${DOCUMENT_ROOT}" | sed -e 's#///#/#g' -e 's#//#/#g' -e 's#/$##g')
    echo "$DOCUMENT_ROOT"
fi

if [ $PREFIX_FLAG -eq 1 ]; then
    FLAGGED=1
    if [ "${BASE_2}" == "account" ]; then
        if [ "${BASE_3}" != "" ]; then
            echo -n "${BASE_3}"
        else
            echo -n "${BASE_1}"
        fi
    else
        echo -n "${BASE_1}"
    fi
    if [ "$BASE_SERVER_NAME" != "" ]; then
        echo ".${BASE_SERVER_NAME}"
    else
        echo
    fi
fi

if [ $DOMAIN_NAME_FLAG -eq 1 ]; then
    FLAGGED=1
    if [ "$(readlink -f "$(pwd)" | grep "\/src\/")" != "" ]; then
        BASE_DOMAIN_NAME="${BASE_SERVER_NAME}"
    else
        declare -i DOMAIN_LEVELS=$(grep -o "\." <<< "${BASE_SERVER_NAME}" | wc -l)
        Debug_Variable DOMAIN_LEVELS 10
        if [ $DOMAIN_LEVELS -eq 0 ] || [ $DOMAIN_LEVELS -eq 1 ]; then
            BASE_DOMAIN_NAME="${BASE_SERVER_NAME}"
        fi
        if [ $DOMAIN_LEVELS -ge 2 ]; then
            BASE_DOMAIN_NAME=$(echo "${BASE_SERVER_NAME}" | awk -F\. '{print $(NF-1)"."$NF}')
        fi
    fi
    if [ "$BASE_DOMAIN_NAME" == "" ]; then
        BASE_DOMAIN_NAME="localdomain"
    fi
    echo "${BASE_DOMAIN_NAME}"
fi

# the default output
if [ $FLAGGED -eq 0 ] || [ $SERVER_NAME_FLAG -eq 1 ]; then
    echo "${BASE_SERVER_NAME}"
fi
